import"@abraham/reflection";import e from"tsyringe";import t from"@abstractflo/shared";import{emitClient as i,offClient as r,onClient as s,onceClient as o,Player as n,Colshape as a}from"alt-server";import{join as c}from"path";import d from"lodash";import l from"fs-extra";import h from"sjcl";import{URLSearchParams as p}from"url";import g from"rxjs";import u from"axios";import{map as v,share as m,filter as f,mergeMap as S,tap as _}from"rxjs/operators";import y from"discord.js";import b from"@overnightjs/core";import w from"body-parser";import C from"cors";import A from"typeorm";function __decorate(e,t,i,r){var s,o=arguments.length,n=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,i):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(e,t,i,r);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(n=(o<3?s(n):o>3?s(t,i,n):s(t,i))||n);return o>3&&n&&Object.defineProperty(t,i,n),n}function __metadata(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}let E=class EventService extends t.BaseEventService{emitClient(e,t,...r){i(e,t,...r)}emitGui(e,r,...s){i(e,t.FrameworkEvent.EventService.ServerEmitGui,r,...s)}offClient(e,t){r(e,t)}onClient(e,t){s(e,t)}onceClient(e,t){o(e,t)}listenHandlerForType(e,t){this.on(e,((...i)=>{const r=i.shift();switch(!0){case["syncedMetaChange","streamSyncedMetaChange"].includes(e):this.handleMetaChangeMethods(r,r.type,t,!0,...i);break;case["entityEnterColshape","entityLeaveColshape"].includes(e):this.handleColShapeMethods(r,t,i.shift(),...i)}}))}handleColShapeMethods(t,i,r,...s){i.forEach((i=>{if(!(t.colshapeType===i.options.colShapeType))return;if(!(void 0!==i.options.name&&t.name===i.options.name))return;if(!(void 0!==i.options.entity&&this.isEntityType(r.type,i.options.entity)))return;e.container.resolveAll(i.targetName).forEach((e=>{e[i.methodName].bind(e)(r,...s)}))}))}};E=__decorate([t.StringResolver,e.singleton()],E);let D=class ConfigService{constructor(){this.file="environment.json",this.path=c(e.container.resolve("server.config.path.file"),this.file),this.customConfig={},this.config=l.readJSONSync(this.path)}get(e,t=null){const i={...this.customConfig,...this.config};return d.get(i,e,t)}set(e,t){this.customConfig=d.set(this.customConfig,e,t)}};D=__decorate([e.singleton(),__metadata("design:paramtypes",[])],D);let x=class EncryptionService{static sha256(e){const t=h.hash.sha256.hash(e);return h.codec.hex.fromBits(t)}static sha256Random(e){return this.sha256(`${e} + ${Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)}`)}};x=__decorate([e.injectable()],x);let O=class DiscordApiProvider{constructor(e){this.configService=e,this.config=this.configService.get("discord")}getAuthUrl(e){return`${this.config.auth_url}?${this.getAuthUrlParams(e)}`}getAuthTokenParams(e){return this.createSearchParams({client_id:this.config.client_id,client_secret:this.config.client_secret,grant_type:"authorization_code",code:e,scope:"identify",redirect_uri:encodeURI(this.config.redirect_url)})}getAuthUrlParams(e){return this.createSearchParams({prompt:"none",response_type:"code",scope:"identify",client_id:this.config.client_id,redirect_uri:encodeURI(this.config.redirect_url),state:e})}createSearchParams(e){return new p(e)}};O=__decorate([e.injectable(),__metadata("design:paramtypes",[D])],O);let P=class DiscordApiService{constructor(e){this.discordApiProvider=e}getToken(e){return g.from(u.post(this.discordApiProvider.config.auth_token_url,this.discordApiProvider.getAuthTokenParams(e),{headers:{"Content-Type":"application/x-www-form-urlencoded"}})).pipe(v((e=>(new t.AccessTokenModel).cast(e.data))))}getUserData(e,i){return g.from(u.get(this.discordApiProvider.config.user_me_url,{headers:{"Content-Type":"application/x-www-form-urlencoded",Authorization:`${e} ${i}`}})).pipe(v((e=>(new t.DiscordUserModel).cast(e.data))))}getAuthUrl(e){return this.discordApiProvider.getAuthUrl(e)}};P=__decorate([t.StringResolver,e.injectable(),__metadata("design:paramtypes",[O])],P);let T=class DiscordBotService{constructor(e){this.configService=e,this.events=[],this.config=(new t.DiscordConfigModel).cast(this.configService.get("discord")),this.client=new y.Client(this.config.presences),this.serviceObservable$=new g.Observable,this.created=!1,this.connect()}autoStart(i){t.UtilsService.log("Starting ~y~DiscordBot~w~"),this.initialize().subscribe((()=>{e.container.register("discord.client",{useValue:this.client}),this.start(),t.UtilsService.log("Started ~lg~DiscordBot~w~"),i()}))}add(e,i,r){const s=(new t.DiscordEventModel).cast({eventName:e,targetName:i,methodName:r});this.events.push(s)}destroy(){this.client.destroy()}initialize(){return this.serviceObservable$}start(){this.events.length&&(t.UtilsService.log("Starting ~y~DiscordBot Decorators~w~"),this.events.forEach((t=>{e.container.resolveAll(t.targetName).forEach((e=>{const i=e[t.methodName].bind(e);this.client.on(t.eventName,i)}))})),t.UtilsService.log("Started ~lg~DiscordBot Decorators~w~"))}connect(){this.serviceObservable$=this.created?this.initialize():this.login()}login(){return this.created=!0,g.defer((()=>g.from(this.client.login(this.config.bot_secret)))).pipe(v((()=>this.client)),m())}};T=__decorate([t.StringResolver,e.singleton(),__metadata("design:paramtypes",[D])],T);let j=class GuildService{constructor(){this.guildBotService=e.container.resolve(T),this.guildConfigService=e.container.resolve(D)}get guild(){const e=this.guildConfigService.get("discord.server_id");return this.guildBotService.client.guilds.cache.get(e)}};j=__decorate([t.StringResolver,e.singleton()],j);const OnDiscord=t=>(i,r,s)=>{const o=t||r,n=e.container.resolve(T),a=s.value;return s.value=function(...e){return a.apply(this,e)},n.add(o,i.constructor.name,r),s};let M=class AuthenticationController{constructor(e,t,i){this.discordApiService=e,this.eventService=t,this.loggerService=i}done(e,t){t.send("Authentication done, you can now close this window").end()}info(e,i){const r=e.query.code,s=e.query.state;if(!r||!s)return i.redirect("done");this.discordApiService.getToken(r).pipe(f((e=>!!e.access_token)),S((e=>this.discordApiService.getUserData(e.token_type,e.access_token))),f((e=>!!e.id&&!!e.username))).subscribe((e=>{e=e.cast({avatarUrl:`https://cdn.discordapp.com/avatars/${e.id}/${e.avatar}.jpg`}),this.eventService.emit(t.FrameworkEvent.Discord.AuthDone,s,e),i.redirect("done")}),(e=>this.loggerService.error(e.message,e.stack)))}};__decorate([b.Get("done"),__metadata("design:type",Function),__metadata("design:paramtypes",[Object,Object]),__metadata("design:returntype",void 0)],M.prototype,"done",null),__decorate([b.Get("discord"),__metadata("design:type",Function),__metadata("design:paramtypes",[Object,Object]),__metadata("design:returntype",void 0)],M.prototype,"info",null),M=__decorate([e.injectable(),b.Controller("auth"),b.ClassMiddleware([C()]),__metadata("design:paramtypes",[P,E,t.LoggerService])],M);let R=class ExpressServer extends b.Server{constructor(){super(),this.app.use(w.json()),this.app.use(w.urlencoded({extended:!0}));const t=e.container.resolve(M);super.addControllers([t])}start(e,t){this.app.listen(e,(()=>{t(e)}))}autoStart(i){t.UtilsService.log("Starting ~y~DiscordApiServer~w~");try{this.port=e.container.resolve("discord.express.port")}catch(e){this.port=1337}this.start(this.port,(()=>{t.UtilsService.log(`Started ~lg~DiscordApiServer~w~ on port ~y~${this.port}~w~`),i()}))}};R=__decorate([e.singleton(),__metadata("design:paramtypes",[])],R);const U=e.container.resolve(LoaderService);e.container.register("EventService",{useValue:e.container.resolve(E)}),e.container.register("ExpressServer",{useValue:e.container.resolve(R)}),e.container.afterResolution(T,(()=>{U.add("before","autoStart","DiscordBotService")}),{frequency:"Once"}),e.container.afterResolution(P,(()=>{U.add("after","autoStart","ExpressServer")}),{frequency:"Once"});let k=class DatabaseService{constructor(e,t){this.configService=e,this.loggerService=t,this.config={...this.configService.get("database"),entities:[]},this.serviceObservable$=new g.Observable,this.created=!1,this.setupEntities(),this.connect()}initialize(){return this.serviceObservable$}connect(){this.serviceObservable$=this.created?this.initialize():this.create()}create(){return this.created=!0,g.defer((()=>(this.loggerService.starting("DatabaseService"),g.from(A.createConnection(this.config))))).pipe(m(),_((()=>this.loggerService.started("DatabaseService"))))}setupEntities(){try{this.entities=e.container.resolve("server.database.entities")}catch(e){this.entities=[]}this.config.entities.push(...this.entities)}};k=__decorate([t.StringResolver,e.singleton(),__metadata("design:paramtypes",[D,t.LoggerService])],k);const OnClient=e=>(i,r,s)=>{const o=e||r,n=(new t.ValidateOptionsModel).cast({name:o});return t.validateEventExistsAndPush(i,"onClient",r,s,n)},OnceClient=e=>(i,r,s)=>{const o=e||r,n=(new t.ValidateOptionsModel).cast({name:o});return t.validateEventExistsAndPush(i,"onceClient",r,s,n)},EntityEnterColShape=(e,i,r)=>(s,o,n)=>{const a=(new t.ValidateOptionsModel).cast({colShapeType:e,name:i,entity:r,eventAddTo:"colShape"});return t.validateEventExistsAndPush(s,"entityEnterColshape",o,n,a)},EntityLeaveColShape=(e,i,r)=>(s,o,n)=>{const a=(new t.ValidateOptionsModel).cast({colShapeType:e,name:i,entity:r,eventAddTo:"colShape"});return t.validateEventExistsAndPush(s,"entityLeaveColshape",o,n,a)};n.prototype=new class PlayerClass extends n{emit(t,...i){e.container.resolve(E).emitClient(this,t,...i)}emitGui(t,...i){e.container.resolve(E).emitGui(this,t,...i)}emitGuiNextTick(e,...i){t.UtilsService.setTimeout((()=>this.emitGui(e,i)),25)}setRealTime(e){this.setDateTime(e.getDate(),e.getMonth(),e.getFullYear(),e.getHours(),e.getMinutes(),e.getSeconds()),this.emit(t.FrameworkEvent.Player.SetRealTime,6e4)}};a.prototype=new class ColshapeClass extends a{};export{D as ConfigService,P as DiscordApiService,T as DiscordBotService,x as EncryptionService,EntityEnterColShape,EntityLeaveColShape,E as EventService,j as GuildService,OnClient,OnDiscord,OnceClient};
