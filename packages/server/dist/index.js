import"@abraham/reflection";import e from"tsyringe";import{BaseEventService as t,FrameworkEvent as i,StringResolver as r,AccessTokenModel as s,DiscordUserModel as o,DiscordConfigModel as n,UtilsService as a,DiscordEventModel as c,LoggerService as d,LoaderService as l,ValidateOptionsModel as h,validateEventExistsAndPush as p}from"@abstractFlo/shared";import{emitClient as u,offClient as g,onClient as m,onceClient as v,Player as f,Colshape as _}from"alt-server";import{join as y}from"path";import S from"lodash";import b from"fs-extra";import C from"sjcl";import{URLSearchParams as w}from"url";import A from"rxjs";import D from"axios";import{map as j,share as E,filter as T,mergeMap as x,tap as O}from"rxjs/operators";import P from"discord.js";import $ from"@overnightjs/core";import R from"body-parser";import M from"cors";import N from"typeorm";function __decorate(e,t,i,r){var s,o=arguments.length,n=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,i):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(e,t,i,r);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(n=(o<3?s(n):o>3?s(t,i,n):s(t,i))||n);return o>3&&n&&Object.defineProperty(t,i,n),n}function __metadata(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}let k=class EventService extends t{emitClient(e,t,...i){u(e,t,...i)}emitGui(e,t,...r){u(e,i.EventService.ServerEmitGui,t,...r)}offClient(e,t){g(e,t)}onClient(e,t){m(e,t)}onceClient(e,t){v(e,t)}listenHandlerForType(e,t){this.on(e,((...i)=>{const r=i.shift();switch(!0){case["syncedMetaChange","streamSyncedMetaChange"].includes(e):this.handleMetaChangeMethods(r,r.type,t,!0,...i);break;case["entityEnterColshape","entityLeaveColshape"].includes(e):this.handleColShapeMethods(r,t,i.shift(),...i)}}))}handleColShapeMethods(t,i,r,...s){i.forEach((i=>{if(!(t.colshapeType===i.options.colShapeType))return;if(!(void 0!==i.options.name&&t.name===i.options.name))return;if(!(void 0!==i.options.entity&&this.isEntityType(r.type,i.options.entity)))return;e.container.resolveAll(i.targetName).forEach((e=>{e[i.methodName].bind(e)(r,...s)}))}))}};k=__decorate([r,e.singleton()],k);let G=class ConfigService{constructor(){this.file="environment.json",this.path=y(e.container.resolve("server.config.path.file"),this.file),this.customConfig={},this.config=b.readJSONSync(this.path)}get(e,t=null){const i={...this.customConfig,...this.config};return S.get(i,e,t)}set(e,t){this.customConfig=S.set(this.customConfig,e,t)}};G=__decorate([e.singleton(),__metadata("design:paramtypes",[])],G);let U=class EncryptionService{static sha256(e){const t=C.hash.sha256.hash(e);return C.codec.hex.fromBits(t)}static sha256Random(e){return this.sha256(`${e} + ${Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)}`)}};U=__decorate([e.injectable()],U);let B=class DiscordApiProvider{constructor(e){this.configService=e,this.config=this.configService.get("discord")}getAuthUrl(e){return`${this.config.auth_url}?${this.getAuthUrlParams(e)}`}getAuthTokenParams(e){return this.createSearchParams({client_id:this.config.client_id,client_secret:this.config.client_secret,grant_type:"authorization_code",code:e,scope:"identify",redirect_uri:encodeURI(this.config.redirect_url)})}getAuthUrlParams(e){return this.createSearchParams({prompt:"none",response_type:"code",scope:"identify",client_id:this.config.client_id,redirect_uri:encodeURI(this.config.redirect_url),state:e})}createSearchParams(e){return new w(e)}};B=__decorate([e.injectable(),__metadata("design:paramtypes",[G])],B);let z=class DiscordApiService{constructor(e){this.discordApiProvider=e}getToken(e){return A.from(D.post(this.discordApiProvider.config.auth_token_url,this.discordApiProvider.getAuthTokenParams(e),{headers:{"Content-Type":"application/x-www-form-urlencoded"}})).pipe(j((e=>(new s).cast(e.data))))}getUserData(e,t){return A.from(D.get(this.discordApiProvider.config.user_me_url,{headers:{"Content-Type":"application/x-www-form-urlencoded",Authorization:`${e} ${t}`}})).pipe(j((e=>(new o).cast(e.data))))}getAuthUrl(e){return this.discordApiProvider.getAuthUrl(e)}};z=__decorate([r,e.injectable(),__metadata("design:paramtypes",[B])],z);let F=class DiscordBotService{constructor(e){this.configService=e,this.events=[],this.config=(new n).cast(this.configService.get("discord")),this.client=new P.Client(this.config.presences),this.serviceObservable$=new A.Observable,this.created=!1,this.connect()}autoStart(t){a.log("Starting ~y~DiscordBot~w~"),this.initialize().subscribe((()=>{e.container.register("discord.client",{useValue:this.client}),this.start(),a.log("Started ~lg~DiscordBot~w~"),t()}))}add(e,t,i){const r=(new c).cast({eventName:e,targetName:t,methodName:i});this.events.push(r)}destroy(){this.client.destroy()}initialize(){return this.serviceObservable$}start(){this.events.length&&(a.log("Starting ~y~DiscordBot Decorators~w~"),this.events.forEach((t=>{e.container.resolveAll(t.targetName).forEach((e=>{const i=e[t.methodName].bind(e);this.client.on(t.eventName,i)}))})),a.log("Started ~lg~DiscordBot Decorators~w~"))}connect(){this.serviceObservable$=this.created?this.initialize():this.login()}login(){return this.created=!0,A.defer((()=>A.from(this.client.login(this.config.bot_secret)))).pipe(j((()=>this.client)),E())}};F=__decorate([r,e.singleton(),__metadata("design:paramtypes",[G])],F);let q=class GuildService{constructor(){this.guildBotService=e.container.resolve(F),this.guildConfigService=e.container.resolve(G)}get guild(){const e=this.guildConfigService.get("discord.server_id");return this.guildBotService.client.guilds.cache.get(e)}};q=__decorate([r,e.singleton()],q);const OnDiscord=t=>(i,r,s)=>{const o=t||r,n=e.container.resolve(F),a=s.value;return s.value=function(...e){return a.apply(this,e)},n.add(o,i.constructor.name,r),s};let I=class AuthenticationController{constructor(e,t,i){this.discordApiService=e,this.eventService=t,this.loggerService=i}done(e,t){t.send("Authentication done, you can now close this window").end()}info(e,t){const r=e.query.code,s=e.query.state;if(!r||!s)return t.redirect("done");this.discordApiService.getToken(r).pipe(T((e=>!!e.access_token)),x((e=>this.discordApiService.getUserData(e.token_type,e.access_token))),T((e=>!!e.id&&!!e.username))).subscribe((e=>{e=e.cast({avatarUrl:`https://cdn.discordapp.com/avatars/${e.id}/${e.avatar}.jpg`}),this.eventService.emit(i.Discord.AuthDone,s,e),t.redirect("done")}),(e=>this.loggerService.error(e.message,e.stack)))}};__decorate([$.Get("done"),__metadata("design:type",Function),__metadata("design:paramtypes",[Object,Object]),__metadata("design:returntype",void 0)],I.prototype,"done",null),__decorate([$.Get("discord"),__metadata("design:type",Function),__metadata("design:paramtypes",[Object,Object]),__metadata("design:returntype",void 0)],I.prototype,"info",null),I=__decorate([e.injectable(),$.Controller("auth"),$.ClassMiddleware([M()]),__metadata("design:paramtypes",[z,k,d])],I);let V=class ExpressServer extends $.Server{constructor(){super(),this.app.use(R.json()),this.app.use(R.urlencoded({extended:!0}));const t=e.container.resolve(I);super.addControllers([t])}start(e,t){this.app.listen(e,(()=>{t(e)}))}autoStart(t){a.log("Starting ~y~DiscordApiServer~w~");try{this.port=e.container.resolve("discord.express.port")}catch(e){this.port=1337}this.start(this.port,(()=>{a.log(`Started ~lg~DiscordApiServer~w~ on port ~y~${this.port}~w~`),t()}))}};V=__decorate([e.singleton(),__metadata("design:paramtypes",[])],V);const H=e.container.resolve(l);e.container.register("EventService",{useValue:e.container.resolve(k)}),e.container.register("ExpressServer",{useValue:e.container.resolve(V)}),e.container.afterResolution(F,(()=>{H.add("before","autoStart","DiscordBotService")}),{frequency:"Once"}),e.container.afterResolution(z,(()=>{H.add("after","autoStart","ExpressServer")}),{frequency:"Once"});let L=class DatabaseService{constructor(e,t){this.configService=e,this.loggerService=t,this.config={...this.configService.get("database"),entities:[]},this.serviceObservable$=new A.Observable,this.created=!1,this.setupEntities(),this.connect()}initialize(){return this.serviceObservable$}connect(){this.serviceObservable$=this.created?this.initialize():this.create()}create(){return this.created=!0,A.defer((()=>(this.loggerService.starting("DatabaseService"),A.from(N.createConnection(this.config))))).pipe(E(),O((()=>this.loggerService.started("DatabaseService"))))}setupEntities(){try{this.entities=e.container.resolve("server.database.entities")}catch(e){this.entities=[]}this.config.entities.push(...this.entities)}};L=__decorate([r,e.singleton(),__metadata("design:paramtypes",[G,d])],L);const OnClient=e=>(t,i,r)=>{const s=e||i,o=(new h).cast({name:s});return p(t,"onClient",i,r,o)},OnceClient=e=>(t,i,r)=>{const s=e||i,o=(new h).cast({name:s});return p(t,"onceClient",i,r,o)},EntityEnterColShape=(e,t,i)=>(r,s,o)=>{const n=(new h).cast({colShapeType:e,name:t,entity:i,eventAddTo:"colShape"});return p(r,"entityEnterColshape",s,o,n)},EntityLeaveColShape=(e,t,i)=>(r,s,o)=>{const n=(new h).cast({colShapeType:e,name:t,entity:i,eventAddTo:"colShape"});return p(r,"entityLeaveColshape",s,o,n)};f.prototype=new class PlayerClass extends f{emit(t,...i){e.container.resolve(k).emitClient(this,t,...i)}emitGui(t,...i){e.container.resolve(k).emitGui(this,t,...i)}emitGuiNextTick(e,...t){a.setTimeout((()=>this.emitGui(e,t)),25)}setRealTime(e){this.setDateTime(e.getDate(),e.getMonth(),e.getFullYear(),e.getHours(),e.getMinutes(),e.getSeconds()),this.emit(i.Player.SetRealTime,6e4)}};_.prototype=new class ColshapeClass extends _{};export{G as ConfigService,z as DiscordApiService,F as DiscordBotService,U as EncryptionService,EntityEnterColShape,EntityLeaveColShape,k as EventService,q as GuildService,OnClient,OnDiscord,OnceClient};
